# **문자열 패턴 찾기**

문자열에서 특정 문자열(Pattern) 효율적으로 찾기 위한 방법을 제시한다.  
여기서 말하는 '효율'이란 Brute Forcing과 비교했을 때 더 나은 시간복잡도를 가질 수 있다는 것을 의미한다.

## **Brute Force**
---------------
기준 문자열 $S$에 대해 특정 패턴 $P$를 찾아야 한다면, 각 문자열의 길이를 $N$과 $M$으로 나타냈을 때 단순 완전탐색을 이용해 $O(NM)$의 시간복잡도를 통해 해결할 수 있다.  

예를들어, `ABDABDBABDABA`라는 문자열에서 `ABDABA`라는 패턴을 찾아야 한다고 가정해보자.

|A|B|D|A|B|<span style="color:red">**D**</span>|B|A|B|D|A|B|A|
|---|---|---|---|---|---|---|---|---|---|---|---|---|
|A|B|D|A|B|<span style="color:red">**A**</span>| | | | | | | |

위 빨간색 부분에서 불일치가 발생했다.  
일반적인 완전탐색에서는 다시 다음과 같은 방법으로 진행할 것이다.

|A|<span style="color:red">**B**</span>|D|A|B|D|B|A|B|D|A|B|A|
|---|---|---|---|---|---|---|---|---|---|---|---|---|
| |<span style="color:red">**A**</span>|B|D|A|B|A| | | | |

첫 단계에서 `ABDAB`까지 일치함을 봤음에도 불구하고 다시 처음부터 확인하는 모습이다.

## **KMP**
-------------------
KMP(Knuth-Morris-Pratt)알고리즘에선 앞서 찾아놓았던 정보를 최대한 효율적으로 이용하며 문자열 패턴을 찾아나간다.

예를들어, 위 예제에서 첫 번째 단계를 거친 후, KMP 알고리즘의 다음단계는 다음과 같다.  
|A|B|D|A|B|D|<span style="color:red">**B**</span>|A|B|D|A|B|A|
|---|---|---|---|---|---|---|---|---|---|---|---|---|
| | | |A|B|D|<span style="color:red">**A**</span>|B|A| | | | |

`ABD`까지의 패턴은 이미 맞는 것을 확인했으므로, 필요없는 중간 단계를 모두 건너뛰었다.  
이를 위해 KMP 알고리즘에선 접두사(Prefix) 및 접미사(Postfix)의 개념과 실패함수(Failure Function)을 이용한다.


## **Failure Fucntion**
-------------
찾을 패턴 $P$(`ABDABA`)를 이용해 실패함수를 구현할 것이다.  
패턴을 이용해 구현한 실패함수를 통해 위 예제처럼 필요없는 부분을 건너띌 수 있는 결정을 내릴 수 있다.

`투포인터`개념을 이용해 실패함수를 만들것이다.  
2개의 `index`에 사용될 `i`와 `j`를 선언한다.  

두 인덱스를 증가시켜 나아가며 `P[i]`와 `P[j]`가 같다면 두 인덱스를 모두 증가시키고, 그렇지 않다면 이전의 실패함수를 통해 값을 채워넣는다.

실패함수의 초기 테이블은 다음과 같다.

|    |A|B|D|A|B|A|
|--- |---|---|---|---|---|---|
|Fail|0| | | | | |
|Idxs|j|i| | | | |

현재, `P[i]`와 `P[j]`가 서로 다르므로 이전의 실패함수를 참고한다.   
이전상태의 실패값이 0이기 때문에 현재 실패값도 0으로 채운 후, `i`를 증가시킨다.

|    |A|B|D|A|B|A|
|--- |---|---|---|---|---|---|
|Fail|0|0| | | | |
|Idxs|j| |i| | | |

`P[i]`와 `P[j]`가 서로 다르므로 이전의 실패함수를 참고한 후, `i`를 증가시킨다.

|    |A|B|D|A|B|A|
|--- |---|---|---|---|---|---|
|Fail|0|0|0| | | |
|Idxs|j| | |i| | |

이번엔 `P[i]`와 `P[j]`이 같으므로 $j+1$을 현재의 실패값으로 채운 후, `i`와 `j`를 모두 증가시킨다.

|    |A|B|D|A|B|A|
|--- |---|---|---|---|---|---|
|Fail|0|0|0|1| | |
|Idxs| |j| | |i| |

역시 `P[i]`와 `P[j]`이 같으므로 $j+1$을 현재의 실패값으로 채운 후, `i`와 `j`를 모두 증가시킨다.

|    |A|B|D|A|B|A|
|--- |---|---|---|---|---|---|
|Fail|0|0|0|1|2| |
|Idxs| | |j| | |i|

마지막으로, `P[i]`와 `P[j]`가 서로 다르므로 이전의 실패함수를 참고한 후, `i`를 증가시킨다.  

여기서, 이전의 실패함수를 참고한다는 것은 이전 인덱스의 실패값으로 `j`를 이동시키며 `P[i]`와 `P[j]`가 서로 같거나 `j`가 0이 될때까지 반복하는 것이다.  
그러므로 최종적으로 다음과 같은 실패함수 테이블이 만들어진다.

|    |A|B|D|A|B|A|
|--- |---|---|---|---|---|---|
|Fail|0|0|0|1|2|1|
|Idxs|j| | | | |i|

위 실패함수는 다음을 이야기하는 것과 같다.  

`A`에서 일치하는 접두사와 접미사의 최대 길이 : 0    
`AB`에서 일치하는 접두사와 접미사의 최대 길이 : 0  
`ABD`에서 일치하는 접두사와 접미사의 최대 길이 : 0  
`ABDA`에서 일치하는 접두사와 접미사의 최대 길이 : 1 (`A`)   
`ABDAB`에서 일치하는 접두사와 접미사의 최대 길이 : 2  (`AB`)  
`ABDABA`에서 일치하는 접두사와 접미사의 최대 길이 : 1 (`A`)  


## **알고리즘**
------------------
위에서 구현한 실패함수를 통해 KMP 알고리즘을 구현할 수 있다.  
`k`번째 `index`에서 불일치가 발생하면 `k-1`번째의 실패함수 값을 이용하는 원리이다.

|A|B|D|A|B|<span style="color:red">**D**</span>|B|A|B|D|A|B|A|
|---|---|---|---|---|---|---|---|---|---|---|---|---|
|A|B|D|A|B|<span style="color:red">**A**</span>| | | | | | | |

패턴의 6번째 `index`에서 불일치가 나타났다.  
실패함수의 5번째 값은 2이다.

위에서도 말했듯이 여기서 2라는 값은 `ABDAB`의 공통 접두사/접미사의 최대 길이가 2라는 뜻이므로 현재 일치하지 않았던 부분에서 2만큼의 앞까지만 패턴을 다시 맞춰준다면 그 이전의 필요없는 작업은 건너띌 수 있다는 말과 같다.

그러므로, 다음과 같은 과정으로 넘어간다.  

|A|B|D|A|B|D|<span style="color:red">**B**</span>|A|B|D|A|B|A|
|---|---|---|---|---|---|---|---|---|---|---|---|---|
| | | |A|B|D|<span style="color:red">**A**</span>|B|A| | | | | 

다시, 패턴의 4번째 `index`에서 불일치가 발생했으므로, 실패함수의 3번째 값을 이용한다.

|A|B|D|A|B|D|<span style="color:red">**B**</span>|A|B|D|A|B|A|
|---|---|---|---|---|---|---|---|---|---|---|---|---|
| | | | | | |<span style="color:red">**A**</span>|B|D|A|B|A| |

|A|B|D|A|B|D|B|<span style="color:skyblue">**A**</span>|<span style="color:skyblue">**B**</span>|<span style="color:skyblue">**D**</span>|<span style="color:skyblue">**A**</span>|<span style="color:skyblue">**B**</span>|<span style="color:skyblue">**A**</span>|
|---|---|---|---|---|---|---|---|---|---|---|---|---|
| | | | | | | | <span style="color:skyblue">**A**</span>|<span style="color:skyblue">**B**</span>|<span style="color:skyblue">**D**</span>|<span style="color:skyblue">**A**</span>|<span style="color:skyblue">**B**</span>|<span style="color:skyblue">**A**</span>|

이로써, 일치하는 문자열 패턴을 찾았다.

## **시간복잡도**
문자열 길이 $N$, 패턴 길이 $M$에 대해 $O(N+M)$의 시간복잡도를 가진다.  
또한, 보통 $N\ge M$ 으로 주이지므로 $O(N)$으로 표현가능하다.