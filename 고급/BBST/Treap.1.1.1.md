# Treap (Cartesian Tree)

Treap은 이진 트리와 이진 힙이 합쳐진 자료구조이다 (Tree + Heap $\Rightarrow$ Treap).

Treap은 순서쌍 $(X, Y)$를 이진 트리에 저장하는데, 이때 $X$를 기준으로는 이진 탐색 트리가 되고 $Y$를 기준으로는 이진 힙이 된다. 만약 트리의 어떤 정점이 값 $(X_0, Y_0)$를 갖는다면, 왼쪽 서브트리의 모든 정점에 대해서는 $X \leq X_0$가 성립하고 오른쪽 서브트리의 모든 정점에 대해서는 $X_0 \leq X$가 성립한다. 그리고 양쪽 서브트리의 모든 정점에 대해서 $Y \leq Y_0$가 성립한다.

Treap은 데카르트 좌표계에 쉽게 나타낼 수 있기 때문에 "Cartesian Tree"라고도 불린다.

![](https://upload.wikimedia.org/wikipedia/commons/e/e4/Treap.svg)

Treap은 1989년에 Raimund Siedel과 Cecilia Argon이 제안하였다.

## Treap의 데이터 저장 방식이 가지는 장점

이러한 구현 방식에서 $X$값은 키(동시에 Treap에 저장된 값)이고 $Y$값은 **우선 순위**이다. 우선 순위가 없으면 Treap은 $X$를 기준으로 한 평범한 이진 탐색 트리이다. $X$값들의 집합은 서로 다른 다양한 트리에 대응된다. 그 중 어떤 것들은 연결 리스트와 같은 형태를 만들기도 해서 매우 느리다 (주요 연산들이 $O(N)$ 시간 복잡도를 가지게 된다).

이때 **우선 순위**(각각 유일한 값을 가진다고 가정)는 만들어지는 트리가 **유일**하게 결정되도록 한다(값을 넣는 순서에 의존하지 않는다). **우선순위를 무작위로 선택**한다면 평균적으로 주요 연산이 $O(\log N)$에 작동하는 트리를 얻을 수 있다. 그래서 Treap의 다른 이름은 **Randomized Binary Search Tree**이다.

## 연산

Treap은 다음과 같은 연산을 제공한다.

+ **Insert (X, Y)** $O(\log N)$
    + 트리에 새로운 정점을 추가한다. $X$값만 넘기고 $Y$값은 내부에서 무작위로 생성하도록 구현하는 것도 가능하다.
+ **Search (X)** $O(\log N)$
    + $X$를 키 값으로 가지는 정점을 찾는다. 일반적인 이진 탐색 트리와 동일하게 구현할 수 있다.
+ **Erase (X)** $O(\log N)$
    + $X$를 키 값으로 가지는 정점을 찾고 트리에서 제거한다.
+ **Build ($X_1, \dots, X_N$)** $O(N)$
    + 리스트의 값을 기반으로 트리를 생성한다. 선형 시간에 이루어질 수 있다 ($X_1, \dots, X_N$이 정렬되어 있다고 가정한다).
+ **Union ($T_1, T_2$)** $O(M \log (N / M))$
    + 원소들이 모두 다르다고 가정하고 두 개의 트리를 병합한다. 중복되는 원소가 병합 과정에서 제거되어야 하는 경우에도 동일한 시간 복잡도를 얻을 수 있다.
+ **Intersect ($T_1, T_2$)** $O(M \log (N / M))$
    + 두 개의 트리의 교집합을 구한다 (공통 원소). 이 글에서 Intersect 연산의 구현은 다루지 않는다.

## 구현

각 정점은 $X, Y$ 값, 왼쪽 자식을 가리키는 포인터($L$), 오른쪽 자식을 가리키는 포인터($R$)을 가진다.

Split과 Merge라는 두 개의 보조 연산을 통해 요구되는 모든 연산을 구현할 것이다.

### Split

![](https://upload.wikimedia.org/wikipedia/commons/6/69/Treap_split.svg)

**Split($T, X$)** 은 트리 $T$를 두 개의 서브트리 $L$과 $R$로 분리한다. $L$은 키 $X_L \leq X$인 원소를 가지고 $R$은 키 $X_R \gt X$인 원소를 가진다. 이 연산의 복잡도는 $O(\log N)$이고 재귀를 통해 구현할 수 있다.

1. 루트 노드의 값(R)이 $X$보다 작거나 같으면 `L`은 적어도 `R->L`과 `R`로 구성된다. `R->R`에 대해 Split을 호출한다. 이때 Split의 결과는 `L'`과 `R'`이다. 최종적으로 `L`은 `L'`또한 포함하며 `R=R'`이다.
2. 루트 노드의 값(R)이 $X$보다 크면 `R`은 적어도 `R`과 `R->R`로 구성된다. `R->L`에 대해 Split을 호출한다. 이때 Split의 결과는 `L'`과 `R'`이다. 최종적으로 `L=L'`이며 `R`은 `R'`또한 포함한다.

그러므로 Split 알고리즘은 다음과 같다.

1. 루트 노드가 왼쪽과 오른쪽 중 어느 서브트리에 속하는지 결정한다
2. 자식중 하나에 대해 재귀적으로 Split을 호출한다
3. 재귀적인 Split 호출을 통해 최종 결과를 생성한다.

### Merge

![](https://upload.wikimedia.org/wikipedia/commons/a/a8/Treap_merge.svg)

**Merge ($T_1, T_2$)** 는 두 개의 서브트리 $T_1$과 $T_2$를 병합하고 새로운 트리를 반환한다. 이 연산의 복잡도 역시 $O(\log N)$이다. 이 연산은 모든 $T_1$의 키가 $T_2$의 키보다 작다는 가정 하에 작동한다. 따라서 우선 순위 $Y$의 순서를 훼손하지 않고 두 트리를 합쳐야 한다. 이를 위해 둘 중 루트 노드의 우선순위 $Y$가 높은 트리를 루트로 선택한다. 나머지 트리 그리고 대응하는 서브트리에 대해 Merge를 재귀적으로 호출한다.

