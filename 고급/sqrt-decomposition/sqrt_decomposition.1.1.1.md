# Sqrt Decomposition

Sqrt Decomposition(제곱근 분할법)은 구간 합 구하기, 최대 최소값 찾기 같이 $O\left(N\right)$에 수행할 수 있는 일반적인 연산을 $O\left(\sqrt n\right)$에 수행할 수 있게 해주는 알고리즘(또는 자료구조)이다.

첫 번째로 제곱근 분할법을 적용하는 가장 단순한 자료구조를 살펴볼 것이다. 그리고 이를 일반화해서 다른 문제에 적용해 볼 것이다. 마지막으로 제곱근 분할법을 약간 다르게 응용해서 사용하는 방법(쿼리를 제곱근 블록으로 쪼개서 처리하는 방법)을 알아볼 것이다.

## 제곱근 분할법을 기반으로 한 자료구조

배열 $a[0 \dots n-1]$가 주어질 때 임의의 $l$과 $r$에 대해서 $a[l \dots r]$의 구간 합을 $O\left(\sqrt n\right)$에 구하는 자료구조를 구현한다.

### 설명

제곱근 분할법의 기본적인 아이디어는 전처리이다. 배열 $a$를 길이가 약 $\sqrt n$인 블록들로 나눈다. 그리고 각각의 블록에 대해 원소의 합을 미리 계산해둔다.

블록 하나의 크기는 $\lceil \sqrt n \rceil$이고 모든 블록의 개수 또한 $\lceil \sqrt n \rceil$이다. $s = \lceil \sqrt n \rceil$라고 하자.

배열 $a$를 다음과 같이 블록들로 나눌 수 있다.

$$\underbrace{a[0], a[1], \dots, a[s-1]}_{\text{b[0]}}, \underbrace{a[s], \dots, a[2s-1]}_{\text{b[1]}}, \dots, \underbrace{a[(s-1) \cdot s], \dots, a[n-1]}_{\text{b[s-1]}}$$

$n$이 $s$의 배수가 아닐 경우 마지막 블록은 다른 블록들보다 적은 개수의 원소를 가진다. 그러나 이것은 이 알고리즘에서 중요한 부분이 아니고 쉽게 처리할 수 있다. 각각의 블록 $k$에 대해서 원소들의 합 $b[k]$를 다음과 같이 나타낼 수 있다.

$$b[k] = \sum\limits_{i=k\cdot s}^{\min {(n-1,(k+1)\cdot s - 1})} a[i]$$

$O(n)$번의 연산으로 $b[k]$의 값을 모두 계산할 수 있다. 이제 쿼리 $[l, r]$의 답을 구하는 방법을 살펴본다. 만약 구간 $[l, r]$이 충분히 길다면 구간은 여러 개의 블록을 포함할 것이다. 각각의 블록에 대해서는 전처리를 했으므로 $O\left(1 \right)$에 블록의 원소의 합을 구할 수 있다. 구간의 양 끝의 경우 블록의 일부만을 포함할 수 있는데 이때는 원소의 합을 직접 계산한다. 

이러한 방법을 통해 연산의 횟수를 매우 줄일 수 있다. 직접 계산해야하는 블록의 일부의 경우 그 크기가 블록의 크기인 $s$를 넘지 않는다. 전처리한 값을 이용하는 블록의 개수 또한 $s$를 넘지 않는다. $s \approx \sqrt n$이기 때문에 구간 $[l, r]$의 합을 구하기 위해서는 $O(\sqrt n)$번의 연산이 필요하다.

## 다른 문제로의 적용

구간 합 쿼리를 처리하는 문제를 확장하여 배열의 원소가 갱신되는 경우를 생각해본다. 만약 원소 $a[i]$가 갱신된다면 $a[i]$가 포함된 블록의 값 $b[k]$를 $O(1)$에 갱신하는 것으로 충분하다.

$$b[k] += a_{new}[i] - a_{old}[i]$$

구간의 합을 구하는 대신 구간의 최대/최소 원소를 구하는 경우를 생각해보자. 이 경우에도 원소를 갱신하는 것이 가능하지만 $b[k]$를 다시 계산하기 위해 블록의 모든 원소를 확인해야 하므로 $O(\sqrt N)$번의 연산이 필요하다.

제곱근 분할법은 값이 $0$인 원소의 개수를 구하기, 처음으로 $0$이 아닌 원소 구하기, 특정 조건을 만족하는 원소의 개수를 구하기와 같은 문제에도 적용할 수 있다.

이제는 구간의 모든 원소를 갱신하는 경우에 대해서 알아본다. 구간 $[l, r]$의 모든 원소에 $\delta$를 더하는 쿼리와 원소의 값 $a[i]$를 구하는 쿼리를 처리하는 문제를 생각해보자. 블록 $k$의 각 원소에 더해져야 하는 값을 $b[k]$에 저장한다. 초기에 $b[k] = 0$이다. 구간에 값을 더하는 쿼리가 주어질 때 구간에 완전히 포함되는 블록의 경우 $\delta$를 $b[k]$에 더한다. 구간에 일부만 포함되는 블록의 경우 $a[i]$에 $\delta$를 일일이 더한다. $i$번째 원소의 값을 구하는 쿼리의 경우 $a[i] + b[i/s]$를 구하는 것으로 충분하다. 첫 번째 쿼리의 경우 $O(\sqrt n)$에 답을 구할 수 있고 두 번째 쿼리의 경우 $O(1)$에 답을 구할 수 있다.

구간 갱신 쿼리와 구간 합 쿼리를 모두 수행할 수도 있다. 두 쿼리 모두 $O(\sqrt n)$번의 연산에 답을 구할 수 있다. 이를 위해서는 구간 갱신을 관리하는 배열 $b$와 구간 합을 관리하는 배열 $c$를 동시에 관리해야 한다.

이외에도 집합에 수를 추가/삭제하는 쿼리, 수가 집합에 포함되는지 확인하는 쿼리, 집합의 $k$번째 수를 구하는 쿼리를 수행하는 문제를 제곱근 분할법으로 해결할 수 있다. 이 문제를 해결하기 위해서는 수를 정렬하고 $\sqrt n$개의 수를 가지는 블록들로 분할해야한다. 또한 수가 추가/삭제될때마다 인접한 블록으로 수를 이동시키며 블록들의 균형을 맞추어주어야 한다.

## Mo's Algorithm

제곱근 분할법에 기반한 Mo's Algorithm으로 $Q$개의 구간 쿼리를 $O((N+Q)\sqrt{N})$에 오프라인으로 해결할 수 있다. 앞에서 다룬 알고리즘보다 시간 복잡도가 약간 좋지 않고 갱신 쿼리를 처리할 수 없기 때문에 유용하지 않을 것 같지만 실제로는 많은 장점을 가지고 있다. 일반적인 제곱근 분할법에서는 각 블록에 대해 전처리를 해두고 쿼리가 들어올 때마다 값들을 조합하여 결과를 만들어야한다. 그러나 어떤 문제에서는 블록의 값을 합치는 것이 어려울 수 있다. 예를 들어 구간의 최빈값을 구하는 문제를 생각해보자. 이 경우 각 블록에서 어떤 수가 몇 번 등장하는지를 별도의 자료구조에 저장해두어야 한다. 이렇게 되면 블록의 값을 빠르게 합쳐서 쿼리를 처리할 수가 없다. Mo's Algorithm은 하나의 자료구조만 관리하는 완전히 다른 방식을 택했기 때문에 이러한 쿼리를 빠르게 처리할 수 있다.

핵심은 인덱스를 기준으로 쿼리의 순서를 변경하여 답을 구하는 것이다. 우선 왼쪽 인덱스가 $0$번 블록에 포함된 쿼리를 모두 처리한다. 그 다음 왼쪽 인덱스가 $1$번 블록에 포함된 쿼리를 모두 처리한다. 이와 같은 방식으로 계속해서 쿼리를 처리한다. 같은 블록에 포함될 경우 오른쪽 인덱스 기준으로 쿼리를 정렬하여 처리한다.

위에서 언급했듯이 Mo's Algorithm은 하나의 자료구조를 관리하는 방식을 사용한다. 이 자료구조에는 구간에 대한 정보를 저장한다. 처음에는 빈 구간이 존재한다. 변경된 쿼리 순서대로 다음 쿼리를 처리할 때에는 단순히 현재 구간의 양쪽 끝에 원소를 추가 또는 삭제하는 것으로 구간의 길이를 필요한 만큼 늘리거나 줄일 수 있다. 이러한 방식을 택하면 자료구조는 하나의 원소를 추가 또는 삭제하는 연산을 지원하는 것으로 충분하다.

쿼리의 답을 구하는 순서를 변경했기 때문에 오프라인으로 쿼리를 수행하는 것이 허용될 때만 Mo's Algorithm을 사용할 수 있다.

### 구현

```cpp
void remove(idx);  // idx의 값을 자료구조에서 삭제한다.
void add(idx);     // idx의 값을 자료구조에 추가한다.
int get_answer();  // 자료구조에서 정답을 추출한다.

int block_size;

struct Query {
    int l, r, idx;
    bool operator<(Query other) const
    {
        return make_pair(l / block_size, r) <
               make_pair(other.l / block_size, other.r);
    }
};

vector<int> mo_s_algorithm(vector<Query> queries) {
    vector<int> answers(queries.size());
    sort(queries.begin(), queries.end());

    // 자료구조 초기화.

    int cur_l = 0;
    int cur_r = -1;
    // invariant: 자료구조는 항상 구간 [cur_l, cur_r]을 반영한다.
    for (Query q : queries) {
        while (cur_l > q.l) {
            cur_l--;
            add(cur_l);
        }
        while (cur_r < q.r) {
            cur_r++;
            add(cur_r);
        }
        while (cur_l < q.l) {
            remove(cur_l);
            cur_l++;
        }
        while (cur_r > q.r) {
            remove(cur_r);
            cur_r--;
        }
        answers[q.idx] = get_answer();
    }
    return answers;
}
```

문제에 따라 다른 자료구조를 선택하고 `add`/`remove`/`get_answer` 함수를 수정해서 사용할 수 있다. 예를 들어 구간 합 쿼리를 처리하는 문제라면 초기값이 $0$인 정수 자료형을 자료구조로 사용할 수 있다. `add` 함수는 인덱스에 해당하는 값을 더한다. `remove` 함수는 해당 인덱스의 값을 뺀다. `get_answer` 함수는 정수를 반환한다.

구간 최빈값 쿼리의 경우 첫번째 이진 탐색 트리(`map<int, int>`)에 현재 구간에 수들이 각각 몇 번씩 나타나는지를 저장해둔다. 두 번째 이진 탐색 트리(`set<pair<int, int>>`)에는 어떤 수가 등장하는 횟수와 해당 수를 순서쌍으로 저장한다. `add` 함수는 해당 인덱스의 수를 두 번째 이진 탐색 트리에서 제거하고 첫 번째 이진 탐색 트리에서는 해당 빈도를 증가시키고 증가한 값이 반영된 순서쌍을 다시 두 번째 이진 탐색 트리에 넣는다. `remove` 함수는 동일하게 구현하나 빈도를 감소시키도록 한다. `get_answer` 함수의 경우 두 번째 트리에서 가장 빈도수에 해당하는 값을 $O(1)$에 찾아 반환한다.

### 복잡도

쿼리를 정렬하는데는 $O\left(Q\log{Q}\right)$가 필요하다.

`add` 함수와 `remove` 함수가 호출되는 횟수를 생각해본다.

블록 하나의 크기를 $S$라고 하자.

우선 왼쪽 인덱스가 모두 같은 블록에 포함된 쿼리만 생각한다. 해당 쿼리는 오른쪽 인덱스를 기준으로 정렬되어있다. 따라서 `add(cur_r)`과 `remove(cur_r)`은 해당 쿼리에 대해 $O(N)$번 호출된다. 모든 블록을 고려하면 $O(\frac{N}{S} N)$번의 호출이 발생한다.

두 쿼리 사이에 값 `cur_l`은 많아야 $O(S)$번 변한다. 따라서 `add(cur_l)`과 `remove(cur_l)`에 대해 $O(SQ)$번의 호출이 추가적으로 발생한다.

$S \approx \sqrt{N}$ 이므로 총 $O((N + Q) \sqrt{N})$번의 연산이 필요하다. 따라서 $O(F)$가 `add` 함수와 `remove` 함수의 복잡도라고 할 때 복잡도는 $O((N+Q)F\sqrt{N})$이다.

### 성능 향상을 위한 팁

+ 블록 크기를 정확하게 $\sqrt{N}$으로 설정해야만 최고의 성능이 나오는 것은 아니다. 예를 들어 $\sqrt{N}=750$이라면 블록 크기가 $700$ 또는 $800$일 때 더 잘 동작할 수도 있다. 더 중요한 것은 블록 크기를 런타임에 계산하면 안된다는 것이다. 상수로 선언하면 컴파일러가 나눗셈을 최적화해준다.

+ 홀수번째 블록에서는 오른쪽 인덱스를 증가하도록 정렬하고 짝수번째 블록에서는 오른쪽 인덱스를 감소하도록 정렬한다. 일반적인 정렬의 경우 블록이 끝날때마다 오른쪽 포인터를 시작점으로 이동시켜야 하지만 이런 식으로 정렬하면 오른쪽 포인터를 초기화 시킬 필요가 없으므로 움직임을 최소화할 수 있다.

이보다 빠른 정렬 접근법은 다음 [코드포스 글](https://codeforces.com/blog/entry/61203)에서 확인할 수 있다.
