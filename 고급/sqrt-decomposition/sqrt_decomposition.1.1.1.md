# Sqrt Decomposition

Sqrt Decomposition(제곱근 분할법)은 구간 합 구하기, 최대 최소값 찾기 같이 $O\left(N\right)$에 수행할 수 있는 일반적인 연산을 $O\left(\sqrt n\right)$에 수행할 수 있게 해주는 알고리즘(또는 자료구조)이다.

첫 번째로 제곱근 분할법을 적용하는 가장 단순한 자료구조를 살펴볼 것이다. 그리고 이를 일반화해서 다른 문제에 적용해 볼 것이다. 마지막으로 제곱근 분할법을 약간 다르게 응용해서 사용하는 방법(쿼리를 제곱근 블록으로 쪼개서 처리하는 방법)을 알아볼 것이다.

## 제곱근 분할법을 기반으로 한 자료구조

배열 $a[0 \dots n-1]$가 주어질 때 임의의 $l$과 $r$에 대해서 $a[l \dots r]$의 구간 합을 $O\left(\sqrt n\right)$에 구하는 자료구조를 구현한다.

### 설명

제곱근 분할법의 기본적인 아이디어는 전처리이다. 배열 $a$를 길이가 약 $\sqrt n$인 블록들로 나눈다. 그리고 각각의 블록에 대해 원소의 합을 미리 계산해둔다.

블록 하나의 크기는 $\lceil \sqrt n \rceil$이고 모든 블록의 개수 또한 $\lceil \sqrt n \rceil$이다. $s = \lceil \sqrt n \rceil$라고 하자.

배열 $a$를 다음과 같이 블록들로 나눌 수 있다.

$$\underbrace{a[0], a[1], \dots, a[s-1]}_{\text{b[0]}}, \underbrace{a[s], \dots, a[2s-1]}_{\text{b[1]}}, \dots, \underbrace{a[(s-1) \cdot s], \dots, a[n-1]}_{\text{b[s-1]}}$$

$n$이 $s$의 배수가 아닐 경우 마지막 블록은 다른 블록들보다 적은 개수의 원소를 가진다. 그러나 이것은 이 알고리즘에서 중요한 부분이 아니고 쉽게 처리할 수 있다. 각각의 블록 $k$에 대해서 원소들의 합 $b[k]$를 다음과 같이 나타낼 수 있다.

$$b[k] = \sum\limits_{i=k\cdot s}^{\min {(n-1,(k+1)\cdot s - 1})} a[i]$$

$O(n)$번의 연산으로 $b[k]$의 값을 모두 계산할 수 있다. 이제 쿼리 $[l, r]$의 답을 구하는 방법을 살펴본다. 만약 구간 $[l, r]$이 충분히 길다면 구간은 여러 개의 블록을 포함할 것이다. 각각의 블록에 대해서는 전처리를 했으므로 $O\left(1 \right)$에 블록의 원소의 합을 구할 수 있다. 구간의 양 끝의 경우 블록의 일부만을 포함할 수 있는데 이때는 원소의 합을 직접 계산한다. 

이러한 방법을 통해 연산의 횟수를 매우 줄일 수 있다. 직접 계산해야하는 블록의 일부의 경우 그 크기가 블록의 크기인 $s$를 넘지 않는다. 전처리한 값을 이용하는 블록의 개수 또한 $s$를 넘지 않는다. $s \approx \sqrt n$이기 때문에 구간 $[l, r]$의 합을 구하기 위해서는 $O(\sqrt n)$번의 연산이 필요하다.

## 다른 문제로의 적용

구간 합 쿼리를 처리하는 문제를 확장하여 배열의 원소가 갱신되는 경우를 생각해본다. 만약 원소 $a[i]$가 갱신된다면 $a[i]$가 포함된 블록의 값 $b[k]$를 $O(1)$에 갱신하는 것으로 충분하다.

$$b[k] += a_{new}[i] - a_{old}[i]$$

구간의 합을 구하는 대신 구간의 최대/최소 원소를 구하는 경우를 생각해보자. 이 경우에도 원소를 갱신하는 것이 가능하지만 $b[k]$를 다시 계산하기 위해 블록의 모든 원소를 확인해야 하므로 $O(\sqrt N)$번의 연산이 필요하다.

제곱근 분할법은 값이 $0$인 원소의 개수를 구하기, 처음으로 $0$이 아닌 원소 구하기, 특정 조건을 만족하는 원소의 개수를 구하기와 같은 문제에도 적용할 수 있다.

이제는 구간의 모든 원소를 갱신하는 경우에 대해서 알아본다. 구간 $[l, r]$의 모든 원소에 $\delta$를 더하는 쿼리와 원소의 값 $a[i]$를 구하는 쿼리를 처리하는 문제를 생각해보자. 블록 $k$의 각 원소에 더해져야 하는 값을 $b[k]$에 저장한다. 초기에 $b[k] = 0$이다. 구간에 값을 더하는 쿼리가 주어질 때 구간에 완전히 포함되는 블록의 경우 $\delta$를 $b[k]$에 더한다. 구간에 일부만 포함되는 블록의 경우 $a[i]$에 $\delta$를 일일이 더한다. $i$번째 원소의 값을 구하는 쿼리의 경우 $a[i] + b[i/s]$를 구하는 것으로 충분하다. 첫 번째 쿼리의 경우 $O(\sqrt n)$에 답을 구할 수 있고 두 번째 쿼리의 경우 $O(1)$에 답을 구할 수 있다.

구간 갱신 쿼리와 구간 합 쿼리를 모두 수행할 수도 있다. 두 쿼리 모두 $O(\sqrt n)$번의 연산에 답을 구할 수 있다. 이를 위해서는 구간 갱신을 관리하는 배열 $b$와 구간 합을 관리하는 배열 $c$를 동시에 관리해야 한다.

이외에도 집합에 수를 추가/삭제하는 쿼리, 수가 집합에 포함되는지 확인하는 쿼리, 집합의 $k$번째 수를 구하는 쿼리를 수행하는 문제를 제곱근 분할법으로 해결할 수 있다. 이 문제를 해결하기 위해서는 수를 정렬하고 $\sqrt n$개의 수를 가지는 블록들로 분할해야한다. 또한 수가 추가/삭제될때마다 인접한 블록으로 수를 이동시키며 블록들의 균형을 맞추어주어야 한다.

## Mo's Algorithm

제곱근 분할법에 기반한 알고리즘으로 $Q$개의 구간 쿼리를 $O((N+Q)\sqrt{N})$에 오프라인으로 해결할 수 있다.
