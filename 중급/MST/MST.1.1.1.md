## **크루스칼**

---

크루스칼 알고리즘은 프림 알고리즘과 함께 가중치가 있는 무방향 그래프에서 MST(Minimum Spanning Tree, 최소신장트리)를 찾기위한 대표적인 알고리즘이다. 

크루스칼 알고리즘은 유니온 파인드를 사용한다. 

MST와 유니온 파인드에 대한 이해가 갖춰졌다면 크루스칼 알고리즘을 구현할 수 있다.


## **설명**

---

대부분의 그래프문제에서는 이중벡터 또는 이차원배열에 노드(정점)들의 정보를 저장하는 것이 일반적인데, 크루스칼 알고리즘에서는 엣지의 정보들을 저장한다.

바로 예시를 보며 이해해보자.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2Fb4SXr9%2FbtrdxnPsS9j%2Fw5gwlFf6tkhZjA3zCPBmtK%2Fimg.png)

다음과 같은 무방향 그래프가 있다고 가정해보자.

**가중치가 가장 작은 엣지들을 고르면서 사이클이 없도록 만드는 것이 목표이다.**

위 목표를 만족하며 크루스칼 알고리즘이 진행되는 모습이다.

![](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FKj9AM%2FbtrdzOl7QsI%2FTH2IKf2E9xKKc8sh3jYTC1%2Fimg.png)

노란색 엣지를 선택하는 순간 사이클이 생겨버리기 때문에 선택하지 않는다.

종료 조건은 선택된 엣지의 개수가 V-1개로 하거나 또는 설정하지 않아도 나머지 엣지들을 고르는 순간 사이클이 생기기 때문에 상관없다.


## **구현**

---

구현단계에서 유니온 파인드에 대한 이해가 필요하다.

유니온 파인드의 `find`와 `merge`함수는 이미 구현이 되어있다고 가정한다.

엣지의 정보를 담아둔 벡터를 가중치순으로 오름차순 정렬을 하고 엣지를 연결하고 있는 두 노드들이 서로 다른 집합이라면 `merge`한 후, 해당 엣지를 채택한다. 채택된 엣지의 개수가 `V-1`개라면 종료한다. 


크루스칼 알고리즘의 시간복잡도에 대해서 간단히 설명하자면,

우선 엣지들을 가중치순으로 정렬해야 하므로 `ElogE` (quick sort)만큼의 시간이 소요되고,

`while`문에서는 `V-1`만큼의 시간이 소요된다.

때문에 전체 시간복잡도는 `O(E*logE)`로 표현될 수 있다.

위 코드를 그대로 사용해서 백준 1197 (최소 스패닝트리)를 해결할 수 있다! 무려 골드 4티어이당.